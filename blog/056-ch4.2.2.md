

## thunkとは

thunk(サンク)とは遅延評価オブジェクトそのものです。

Racketでもdelayでthunkをつくることができます。(promiseという名前ですが)

```scheme
racket@> (define x (delay (+ a b)))
racket@> x
#<promise:x>
```

xはthunkそのものであり、```(+ a b)```はまだ評価されていない。

```scheme
racket@> (define a 1)
racket@> (define b 2)
racket@> (force x)
3
```

この```(force x)```でthunkが持っている式が評価され、得られた結果はthunkにメモされる。

```scheme
racket@> (define a 4)
racket@> (define b 5)
racket@> (force x)
3
```

一度結果がメモ化されるとthunkはその値を返すので、```a```、```b```の値を変えても```(force x)```の結果は変わらない。


## thunkの実装

本文に倣って実装してみる。

```scheme
;;; 遅延オブジェクトの生成
(define (delay-it exp env)
  (list 'thunk exp env))

;;; 遅延オブジェクトの評価
;;; @note set-car!/set-cdr!を使うのでr5rsをrequireする必要がある
(define (force-it obj)
  (cond ((tagged-list? obj 'evaluated-thunk)
		 (cadr obj)) ;; its value
		((tagged-list? obj 'thunk)
		 ((let ((value (force-it (eval-proc exp env))))
			(set-car! obj 'evaluated-thunk)
			(set-car! (cdr obj) value) ;; replace expression with its value
			(set-cdr! (cdr obj) '())   ;; forget environment
			value)))
		(else obj))) ;; not delayed object
```

## 遅延評価器を動作させる

てっきり§4.1.7の構文解析と実行を分離した評価器を使うかと思ったら、§4.1.1の最初に出た評価器に対しての修正だったので萎えてしまった。。

せっかくthunkを実装したけど、いまさら最初の評価器を触るのは面倒すぎるので、SICPのサイトにあるサンプルコードをを使わてもらう。


(1) 以下からサンプルコードをダウンロードして展開
- https://mitpress.mit.edu/sicp/code/index.html からallcode.tar.gzをダウンロード

(2) いつものようにemacs/geiserからrakcetを起動し以下を実行

```scheme
racket@> (require r5rs)
racket@> (load "ch4-leval.scm")
'LAZY-EVALUATOR-LOADED
racket@> (define the-global-environment (setup-environment))
racket@> (driver-loop)

;;; L-Eval input:

```

(3) テキスト本文のコードを打ち込んでみる

```scheme
;;; L-Eval input:
(define (try a b)
  (if (= a 0) 1 b))

;;; L-Eval value:
ok

;;; L-Eval input:
(try 0 (/ 1 0))

;;; L-Eval value:
1
```

ちゃんと動いている。


### 問題 4.27

```scheme
(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define w (id (id 10)))
```

に対して

```scheme
> count ;; => ???

> w     ;; => ???

> count ;; => ???
```

の結果は次の通り。

|       | 遅延評価なし | 遅延評価あり |
|-------|------------|------------|
|count  |2           |1           |
|w      |10          |10          |
|count  |2           |2           |



遅延評価ありの場合の ```(define w (id (id 10)))``` について

- ```define```はspecial formのため、外側の```id```は即座に評価される
- 外側の```id```はcompound procedureのため、内側の```id```は遅延評価される

ので、最初の```count```は```1```となる。

その後で```w```を評価する際に、遅延された```id```が評価されるため二回目の```count```は```2```となる。


### 問題 4.29

#### a.

すごい既視感があるんだけど、フィボナッチ数と計算とか。

計算の中で```f(k)```の```k```が何度も出るようなパターンでは、メモ化するとしないで全然違う。一概には言えないが、オーダーでいうと```O(n)```と```O(n)```〜```O(n^2)```くらいは違うはず。

#### b.

```scheme
(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define (square x)
  (* x x))
```

とした場合、メモ化ありなしで、

```scheme
> (square (id 10)) ;; => ???

> count            ;; => ???
```

の応答結果はどう違うか？

|             | メモ化あり | メモ化なし |
|-------------|----------|-----------|
|(square ...) |100       |100        |
|count        |1         |2          |

まず ```(square ...)``` はcompound procedureなので次のように簡約される。

```scheme
   (square (id 10))
=> (* <thunk (id 10)> <thunk (id 10)>)
=> (* (force <thunk (id 10)>) (force <thunk (id 10)>)) ;; ここでthunkを評価
=> (* 10 10)
=> 100
```

メモ化ありの場合```(id 10)```の結果はメモ化されるので二回目の```(id 10)```の評価で内部の処理は走らない、メモ化なしだと走る、ので```count```の結果が異なる。


### 問題 4.30

転校したCプログラマのCy D. Fect = side effectですか(笑)

#### a.

確かに、

```scheme
(define (for-each proc items)
  (if (null? items)
	  'done
	  (begin (proc (car items))
			 (for-each proc (cdr items)))))
```

のprocの評価の際に渡される```(car items)```はthunkとなるが、

```scheme
(for-each (lambda (x) (newline) (display x))
                  (list 57 321 88))
```

displayがprimitive procedureなので、そこでthunkが評価されてしまい、正しく出力される。


#### b.

```scheme
(define (p1 x)
  (set! x (cons x '(2)))
  x)

(define (p2 x)
  (define (p e)
	e
	x)
  (p (set! x (cons x '(2)))))
```

において、元々のeval-sequenceでの結果は以下の通り。

```scheme
;;; L-Eval input:
(p1 1)

;;; L-Eval value:
(1 2)

;;; L-Eval input:
(p2 1)

;;; L-Eval value:
1
```

普通に考えると```(p2 1) => (1 2)```となってほしいところが、```(p2 1) => 1```となってしまう。

Cyが提案したeval-sequenceでの結果は以下の通り。

```scheme
;;; L-Eval input:
(p1 1)

;;; L-Eval value:
(1 2)

;;; L-Eval input:
(p2 1)

;;; L-Eval value:
(1 2)
```

