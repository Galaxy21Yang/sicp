計算機科学の勉強にSICPを読もう - #11 第2章 データによる抽象の構築 (pp.73-83 図形言語 #3)
======================================

引き続き「§2.2.4 図形言語」。いよいよ終盤。


ペインタの変換と組み合わせ
-------------------------------------

transform-painterというペインタのフレーム変換を行う手続きを定義する。

```scheme
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
```

これを使えば、上下を反転させたペインタを返す
flip-vertという手続きは、フレームの頂点の入れ替えだけで定義できる。

```scheme
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)    ; new origin
                     (make-vect 1.0 1.0)    ; new end of edge1
                     (make-vect 0.0 0.0)))  ; new end of edge2
```

実行結果。

```scheme
racket@> (draw (flip-vert wave))
```

![image]()

素晴らしい。

左右に分割して並べたペインタを返す、beside手続き。

```scheme
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
```

実行結果。

```scheme
racket@> (draw (beside wave wave))
```

![image]()


#### 問題 2.50

flip-horiz、rotate180、rotate270を実装する。フレームの頂点を入れ替えるだけ。

```scheme
(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))

(define (rotate180 painter)
  (flip-vert (flip-horiz painter)))

(define (rotate270 painter)
  (flip-vert (flip-horiz (rotate90 painter))))
```

#### 問題 2.51

2つのペインタをフレームの上下に配置するbelowを実装する。

```scheme
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
							  (make-vect 1.0 0.0)
                              split-point))
          (paint-up
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-bottom frame)
        (paint-up frame)))))
```

ここまで来ると、テキストのflipped-pairsが動かせる。

```scheme
racket@> (draw (flipped-pairs wave))
```

![image]()

### 問題 2.44-45

```
(define right-split (split beside below))
(define up-split (split below beside))
```

が与えられているものとしてsplitを実装し、right-splitおよびup-splitを完成させる。

```
(define (split op1 op2)
  (define (proc painter n)
	(if (= n 0)
		painter
		(let ((smaller (proc painter (- n 1))))
		  (op1 painter (op2 smaller smaller)))))
  proc)
```

これでテキストの全ての例が動かせるようになった！

```scheme
racket@> (draw (corner-split wave 4))
```

![image]()

```scheme
racket@> (draw (square-limit wave 4))
```

![image]()


頑健な設計のための言語レベル
--------------------------------

「図形言語」で言いたいことがおおよそここでまとめられている。

振り返ると、この言語は

- アプリケーション (ペインタの変換/組み合わせ)
- ペインタ
- フレーム
- セグメント
- ベクトル
- プリミティブ (キャンバスなど描画回り)

でレイヤー化されており、それぞれの構造が独立性を保ったまま組み合わされている。

加えてそれぞれのレイヤーのロバスト性も担保されており、
他のレイヤーに影響を与えることなく、レイヤーの内部構造を変更することができる。
（セグメントやベクトルのコンストラクタ・アクセサの作り変え等がその例）

ペインタは、リスト構造ではなく手続きによるオブジェクトとしたため、
ペインタの変換/組み合わせは、ペインタのデータ構造や描画方法の詳細を知らずとも、
それらが実装できるようになったことは、この章で最も学ぶべきことだろう。

その他、フレーム変換や異なる座標系のマッピングなどを
CG的な要素も理解できればよいのではないかと思う。


ソースコードの全体はGitHubにアップしているので、良かったら参考にしてみてください。

- 

やたら時間がかかったけど、次は「§2.3 記号データ」から。

--------------------------------

※「計算機科学の勉強にSICPを読もう」の目次は[こちら](/entry/2014/05/25/000000)




