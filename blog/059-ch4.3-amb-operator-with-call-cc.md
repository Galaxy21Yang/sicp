

#### SICPのamb評価器を試すには

SICP本家からサンプルコードをダウンロードし、


Racket REPLで、

```scheme
racket@> (require r5rs)
racket@> (load "ch4-ambeval.scm")
'AMB-EVALUATOR-LOADED
racket@> (define the-global-environment (setup-environment))
racket@> (driver-loop)

;;; Amb-Eval input:

```

とすればよい。


### ambのインターフェース

REPL上で、

```scheme
(amb 1 2 3)
```

とした場合、

- 1,2,3の選択肢がセットされ、どれかひとつを返す。すでに選択肢がセットされていた場合、これまでのものは捨てられ、与えられた選択肢がセットされる
- REPLで```'try-again```とすると、残りの選択肢からひとつ探索する
- 選択肢がなくなった場合、```There are no more values of ...```とprintし、何もしない

ただし、REPLではなくコード上で```(amb <choices> ...)```を呼ぶ場合、

- ```<choices>```がある場合、新たな選択肢の組み合わせが追加される
- ```<choices>```がない場合、残りの選択肢からひとつ探索する (```'try-again```と同じ)

となっている。

選択肢のうち、本質的にどれが選択されるかわからないが、どれかひとつを選択する計算を「非決定性計算」と呼ぶらしい。


### ambの選択肢の探索

例えば、以下のようなコードをREPLに与えると、

```scheme
;;; Amb-Eval input:
(let ((x (amb 1 2 3))
	  (y (amb 'a 'b)))
  (list x y))

;;; Starting a new problem 
;;; Amb-Eval value:
(1 a)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(1 b)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(2 a)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(2 b)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(3 a)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(3 b)

;;; Amb-Eval input:
try-again

;;; There are no more values of
(let ((x (amb 1 2 3)) (y (amb (quote a) (quote b)))) (list x y))

;;; Amb-Eval input:
try-again

;;; There is no current problem
```

集合 ```'(1 2 3)``` と ```'(a b)``` の内積を逐次返すコードとなる。


これは、深さ優先探索のように選択肢を探索している。


### call/ccによるambオペレータの実装

とは言え、SICPテキストのamb評価器を使ってもRacketの豊富な組み込みライブラリの恩恵が受けられないので、この先この評価器を使って問題を解いていくのは辛そう。

そこで、ambオペレータをcall/ccを使って実装する。

ほとんどOn Lispのコードを少し改変しただけですが。。

与えられた選択肢からひとつを選び、残りの選択肢をキュー（コード上の```*alternatives*```）にpushする手続き```choose```を実装する。

```scheme
(define *alternatives* '())

(define (choose choices)
  (if (null? choices)
	  (try-again)
	  (call/cc
	   (lambda (cc)
		 (set! *alternatives*
			   (cons
				(lambda ()
				  (cc (choose (cdr choices))))
				*alternatives*))
		 (car choices)))))
```

残りの選択肢をキューにpushする際に```(lambda () (cc (choose (cdr choices))))```とccを付けるのがポイント。ccを呼ぶことで、残りの選択肢から選ぶ度に```(amb <choices> ...)```を実行したコンテキストまで戻すことができる。

次に、残りの選択肢```*alternatives*```から選び直す手続き```try-again```を実装する。これは```*alternatives*```から手続きをpopし実行するだけなので、わかりやすい。

```scheme
(define try-again false)
	
(call/cc
 (lambda (cc)
   (set! try-again
		 (lambda ()
		   (if (null? *alternatives*)
			   (cc '(there are no more values))
			   (let ((next (car *alternatives*)))
				 (set! *alternatives* (cdr *alternatives*))
				 (next)))))))
```

あとは、```choose```のラッパーとして```amb```を定義。

```scheme
(define (amb . choices)
  (choose choices))
```

上記をamb.scmというファイルで保存し、Racket REPLで動かしてみる。

```scheme
racket@> (load "amb.scm")
racket@> (let ((x (amb 1 2 3))
			   (y (amb 'a 'b)))
		   (list x y))
'(1 a)
racket@> (try-again)
'(1 b)
racket@> (try-again)
'(2 a)
racket@> (try-again)
'(2 b)
racket@> (try-again)
'(3 a)
racket@> (try-again)
'(3 b)
racket@> (try-again)
'(there are no more values)
```

できた！

このときの動作は以下のようになる。



### ambオペレータ以外の手続き

まずは```require```。

Racket組み込みの```require```を奪われるとさすがに辛いので、```req```という名前で定義する。また、Racketはif構文でaltenative節がないのを許ないので、適当に```false```を返すようにしておく。

```scheme
(define (req p)
  (if (not p) (amb) false))
```

次に```an-element-of```。SICPの通りの実装だと…

```scheme
(define (an-element-of items)
  (req (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
```

実行時にamb手続きの引数が先に評価されてしまうので、```an-element-of```の評価の無限ループに嵌まり返ってこなくなる。

そこで引数を遅延オブジェクト化する。

```scheme
(define (an-element-of items)
  (req (not (null? items)))
  (amb (car items) (delay (an-element-of (cdr items)))))
```

反対にambオペレータの実装となる```choose```ではforceさせる。

```scheme
(define (choose choices)
  (if (null? choices)
	  (try-again)
	  (call/cc
	   (lambda (cc)
		 (define try-next
		   (lambda () (cc (choose (cdr choices)))))
		 (set! *alternatives*
			   (cons try-next *alternatives*))
		 (force (car choices)))))) ;; ここでforce
```

これで```an-element-of```が動くようになった。

```scheme
racket@> (an-element-of '(1 3 5))
1
racket@> (try-again)
3
racket@> (try-again)
5
racket@> (try-again)
'(there are no more values)
```

これで```prime-sum-pair```も問題なく動く。

```scheme
racket@> (require math/number-theory) ;; prime?のためにロード

racket@> (define (prime-sum-pair list1 list2)
		   (let ((a (an-element-of list1))
				 (b (an-element-of list2)))
			 (req (prime? (+ a b)))
			 (list a b)))

racket@> (prime-sum-pair '(1 3 5 8) '(20 35 110))
'(3 20)
racket@> (try-again)
'(3 110)
racket@> (try-again)
'(8 35)
racket@> (try-again)
'(there are no more values)
```


ここまでのソースコードは以下に置いています。

-
-

次からは§4.3練習問題を解いていきます。


--------------------------------

※「SICP読書ノート」の目次は[こちら](/entry/sicp/index)


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

